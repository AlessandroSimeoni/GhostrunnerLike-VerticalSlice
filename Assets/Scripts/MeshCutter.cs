using System;
using System.Collections.Generic;
using UnityEngine;

namespace MeshCut
{
	public class MeshCutter : MonoBehaviour
	{
#if UNITY_EDITOR

		[SerializeField] private Sliceable theTarget;
		[SerializeField] private Transform planeTransform;

		[ContextMenu("TestCut")]
		private void TestCut()
		{
			Cut(theTarget, planeTransform.up, Vector3.zero);
		}
#endif

		/// <summary>
		/// Cut the target mesh in half using a plane with planeNormal normal passing for the planePosition position
		/// </summary>
		/// <param name="target">The target to cut</param>
		/// <param name="planeNormal">The normal of the cut plane</param>
		/// <param name="planePosition">The position of the cut plane</param>
		public void Cut(Sliceable target, Vector3 planeNormal, Vector3 planePosition)
        {
            Plane plane = new Plane(
                target.transform.InverseTransformDirection(planeNormal),
                target.transform.InverseTransformPoint(planePosition)
                );

            CutGeneratedMesh leftMesh = new CutGeneratedMesh();     // mesh on the positive side of the plane
            CutGeneratedMesh rightMesh = new CutGeneratedMesh();    // mesh on the negative side of the plane

            bool split = false;     // used to know if the target has been cut in half or not

            // loop for each submesh in the target's mesh
            for (int i = 0; i < target.mesh.subMeshCount; i++)
            {
                // get all the triangles in the current submesh
                int[] submeshTriangles = target.mesh.GetTriangles(i);

                // loop for each triangle in the current submesh
                for (int j = 0; j < submeshTriangles.Length; j += 3)
                {
                    MeshTriangle currentTriangle = GetTriangle(target.mesh, i, submeshTriangles, j);

                    // creates an array which tells, for every vertex of the triangle, in which side of the plane they are.
                    // If true then the vertex is on the positive side if the plane (in the direction of the normal), otherwise the vertex is on the negative side
                    bool[] side = new bool[]
                    {
                        plane.GetSide(currentTriangle.vertices[0]),
                        plane.GetSide(currentTriangle.vertices[1]),
                        plane.GetSide(currentTriangle.vertices[2])
                    };

                    if (side[0] == side[1] && side[1] == side[2])
                    {
                        // if all the vertices are on the same side of the plane, the triangle can be added to the mesh without cutting it
                        if (side[0])
                            leftMesh.AddTriangle(currentTriangle);
                        else
                            rightMesh.AddTriangle(currentTriangle);
                    }
                    else
                    {
                        // split the current triangle
                        SplitTriangle(currentTriangle, side, plane, leftMesh, rightMesh);
                        split = true;
                    }
                }
            }

            // don't continue if no triangle has been cut
            if (!split)
                return;

            MeshRenderer targetRenderer = target.GetComponent<MeshRenderer>();

            // fill the holes generated by the cut process
            FillMeshHoles(leftMesh, rightMesh, plane, targetRenderer.materials.Length);

            // initialize the two meshes
            leftMesh.InitMesh();
            rightMesh.InitMesh();
            
            PrepareRightGameObject(target, rightMesh, targetRenderer, plane, 25.0f);	// right mesh will take the place of the current mesh of the target
            PrepareLeftGameObject(target, leftMesh, targetRenderer, plane, 25.0f);		// left mesh will be the new generated object
        }

        /// <summary>
        /// Create the gameobject containing the left mesh of the original target.
        /// The gameobject created will have:
        ///		- the same transform of the original target;
        ///		- a mesh filter with new mesh associated;
        ///		- a mesh renderer with the same materials as the original target (also containing the fill material if the right gameobject has already been processed)
        ///		- a mesh collider
        ///		- a rigidbody
        ///	The gameObject will also receive a force applied to it in the direction of the cut plane
        /// </summary>
        /// <param name="target">the target to cut</param>
        /// <param name="plane">the cut plane</param>
        /// <param name="leftMesh">the mesh of the positive side of the cut</param>
        /// <param name="targetRenderer">the target's MeshRenderer</param>
        /// <param name="cutForce">the force applied to the object</param>
        private void PrepareLeftGameObject(Sliceable target, CutGeneratedMesh leftMesh, MeshRenderer targetRenderer, Plane plane, float cutForce)
        {
            GameObject leftSideGO = new GameObject(target.name + " [Left Cut]");
            leftSideGO.transform.position = target.transform.position;
            leftSideGO.transform.rotation = target.transform.rotation;
            leftSideGO.transform.localScale = target.transform.localScale;

            leftSideGO.AddComponent<MeshFilter>().mesh = leftMesh.mesh;

            leftSideGO.AddComponent<MeshRenderer>().materials = targetRenderer.materials;

            MeshCollider leftMeshCollider = leftSideGO.AddComponent<MeshCollider>();
            leftMeshCollider.sharedMesh = leftMesh.mesh;
            leftMeshCollider.convex = true;

            leftSideGO.AddComponent<Rigidbody>().AddForce(plane.normal * cutForce);
        }

        /// <summary>
        /// Set up the gameobject containing the right mesh of the original target.
		/// This does not create a new gameobject, but modifies the gameobject of the original target.
		/// All original colliders of the target will be removed.
        /// The gameobject will have:
        ///		- a mesh filter with new mesh associated;
        ///		- a mesh renderer with updated materials (the fill material will be added)
        ///		- a mesh collider
        ///		- a rigidbody
        ///	The gameObject will also receive a force applied to it in the opposite direction of the cut plane
        /// </summary>
        /// <param name="target">the target to cut</param>
        /// <param name="plane">the cut plane</param>
        /// <param name="rightMesh">the mesh of the negative side of the cut</param>
        /// <param name="targetRenderer">the target's MeshRenderer</param>
        /// <param name="cutForce">the force applied to the object</param>
        private void PrepareRightGameObject(Sliceable target, CutGeneratedMesh rightMesh, MeshRenderer targetRenderer, Plane plane, float cutForce)
        {
            // remove all original colliders
            Collider[] targetOriginalColliders = target.GetComponents<Collider>();
            foreach (Collider collider in targetOriginalColliders)
                Destroy(collider);

            target.GetComponent<MeshFilter>().mesh = rightMesh.mesh;

            Material[] newMaterials = new Material[targetRenderer.materials.Length + 1];
            targetRenderer.materials.CopyTo(newMaterials, 0);
            newMaterials[^1] = target.fillMaterial;     // ^1 access the last element of the array, it's the same as newMaterials[newMaterials.Length-1]
            targetRenderer.materials = newMaterials;

            MeshCollider targetCollider = target.gameObject.AddComponent<MeshCollider>();
            targetCollider.sharedMesh = rightMesh.mesh;
            targetCollider.convex = true;

            target.gameObject.AddComponent<Rigidbody>().AddForce(-plane.normal * cutForce);
        }

		/// <summary>
		/// Fills the left and right holes generated by the cut of the mesh
		/// </summary>
		/// <param name="leftMesh">the left side mesh</param>
		/// <param name="rightMesh">the right side mesh</param>
		/// <param name="plane">the cut plane</param>
		/// <param name="subMeshIndex">the submesh index that will be associated to the new triangles</param>
        private void FillMeshHoles(CutGeneratedMesh leftMesh, CutGeneratedMesh rightMesh, Plane plane, int subMeshIndex)
		{
			if (leftMesh.intersectionPoints.Count == 0) // if there are no intersection points return
				return;

            // calculate the center of the intersection points of the mesh
            // (left and right meshes have the same intersection points, so it doesn't make any difference using one or the other)
            Vector3 holeCenter = Vector3.zero;
			for (int i = 0; i < leftMesh.intersectionPoints.Count; i++)
				holeCenter += leftMesh.intersectionPoints[i].vertex;
			holeCenter /= leftMesh.intersectionPoints.Count;

			// Calculate the two vectors which will be used as reference to calculate the uvs for each intersection point.
			// I'm using the first vertex as reference to calculate the first vector.
			// The two vectors will be at 90° from each other
			Vector3 firstRefVector = Vector3.Cross(leftMesh.intersectionPoints[0].vertex - holeCenter, plane.normal);
			Vector3 secondRefVector = Vector3.Cross(plane.normal, firstRefVector);
			Vector2 uvCenter = new Vector2(0.5f, 0.5f);     // in the center of the hole the uv is set to be (0.5f, 0.5f)

            // calculate the uvs for each intersection point
            // (as above, left and right meshes have the same intersection points, so it doesn't make any difference using one or the other)
            for (int i = 0; i < leftMesh.intersectionPoints.Count; i++)
			{
				Vector3 fromCenterToVertex = leftMesh.intersectionPoints[i].vertex - holeCenter;

                // the uv for x/y axis is calculated with a dot product between the firstRefVector/secondRefVector and the vector from center to the current vertex.
                // the resulting value is then mapped in the range [0.0f, 1.0f] by adding 1 and multiplying the result for 0.5f
                float xValue = (Vector3.Dot(firstRefVector, fromCenterToVertex) + 1) * 0.5f;
				float yValue = (Vector3.Dot(secondRefVector, fromCenterToVertex) + 1) * 0.5f;

				leftMesh.intersectionPoints[i].uv = new Vector2(xValue, yValue);
				rightMesh.intersectionPoints[i].uv = new Vector2(xValue, yValue);
			}

			// triangles creation
			for (int i = 0; i < leftMesh.intersectionPoints.Count; i += 2)
			{
				// LEFT SIDE HANDLING
				Vector3[] leftVertices = new Vector3[] { leftMesh.intersectionPoints[i].vertex, leftMesh.intersectionPoints[i + 1].vertex, holeCenter };
				Vector3[] normals = new Vector3[] { -plane.normal, -plane.normal, -plane.normal };		// normals for the left side will be on the opposite direction of the cut plane
				Vector2[] leftUvs = new Vector2[] { leftMesh.intersectionPoints[i].uv, leftMesh.intersectionPoints[i + 1].uv, uvCenter };

				MeshTriangle leftSideTriangle = new MeshTriangle(leftVertices, normals, leftUvs, subMeshIndex);

				if (IsFacingWrongSide(leftVertices, normals[0]))
					FlipTriangle(leftSideTriangle);

				leftMesh.AddTriangle(leftSideTriangle);

				// RIGHT SIDE HANDLING
				// flip the normals
				for (int j = 0; j < 3; j++)
					normals[j] *= -1;

				Vector3[] rightVertices = new Vector3[] { rightMesh.intersectionPoints[i].vertex, rightMesh.intersectionPoints[i + 1].vertex, holeCenter };
				Vector2[] rightUvs = new Vector2[] { rightMesh.intersectionPoints[i].uv, rightMesh.intersectionPoints[i + 1].uv, uvCenter };
				MeshTriangle rightSideTriangle = new MeshTriangle(rightVertices, normals, rightUvs, subMeshIndex);

				if (IsFacingWrongSide(rightVertices, normals[0]))
					FlipTriangle(rightSideTriangle);

				rightMesh.AddTriangle(rightSideTriangle);
			}
		}

		/// <summary>
		/// Split the triangle in two halves along the cut plane
		/// </summary>
		/// <param name="targetTriangle">the triangle to split</param>
		/// <param name="side">the array to know where is each vertex compared to the plane</param>
		/// <param name="plane">the cut plane</param>
		/// <param name="leftMesh">the mesh for the part above the plane</param>
		/// <param name="rightMesh">the mesh for the part below the plane</param>
		private void SplitTriangle(MeshTriangle targetTriangle, bool[] side, Plane plane, CutGeneratedMesh leftMesh, CutGeneratedMesh rightMesh)
		{
            // each splitted triangle will have two intersection points with the plane
            IntersectionPoint[] intersectionPoints = new IntersectionPoint[2];

			int intersectionIndex = 0;
			List<int> positiveSideVertexIndex = new List<int>();	// this list will contain the indexes of the vertices in the POSITIVE side of the plane
			List<int> negativeSideVertexIndex = new List<int>();    // this list will contain the indexes of the vertices in the NEGATIVE side of the plane

            // find intersection points
            for (int i = 0; i < 3; i++)
			{
				if (side[i])
					positiveSideVertexIndex.Add(i);
				else
					negativeSideVertexIndex.Add(i);

				int nextSide = (i + 1) % 3;
				if (side[i] == side[nextSide])		// skip if vertices are on the same side
					continue;

				// in order to get the intersection point we must cast a ray from one vertex to the vertex on the other side of the plane.
				// the plane.RayCast will return the distance of the plane from the ray's source vertex
				float distanceFromPlane;
				Vector3 direction = targetTriangle.vertices[nextSide] - targetTriangle.vertices[i];
				Ray ray = new Ray(targetTriangle.vertices[i], direction);
				plane.Raycast(ray, out distanceFromPlane);

				// normalize the distance to correctly calculate the vertex, normal and uv of the intersection point
				distanceFromPlane = distanceFromPlane / direction.magnitude;

				intersectionPoints[intersectionIndex] = new IntersectionPoint();
				intersectionPoints[intersectionIndex].vertex = Vector3.Lerp(targetTriangle.vertices[i], targetTriangle.vertices[nextSide], distanceFromPlane);
				intersectionPoints[intersectionIndex].normal = Vector3.Lerp(targetTriangle.normals[i], targetTriangle.normals[nextSide], distanceFromPlane);
				intersectionPoints[intersectionIndex].uv = Vector2.Lerp(targetTriangle.uvs[i], targetTriangle.uvs[nextSide], distanceFromPlane);
				intersectionPoints[intersectionIndex].directlyConnectedVertices[0] = targetTriangle.vertices[i];
				intersectionPoints[intersectionIndex].directlyConnectedVertices[1] = targetTriangle.vertices[nextSide];
				intersectionIndex++;
			}

			leftMesh.intersectionPoints.AddRange(intersectionPoints);
			rightMesh.intersectionPoints.AddRange(intersectionPoints);

			if (positiveSideVertexIndex.Count == 1)
			{
				// handle single vertex on positive side
				leftMesh.AddTriangle(CreateSingleSideTriangle(targetTriangle, intersectionPoints, positiveSideVertexIndex[0]));

				// handle double vertices on negative side
				AddDoubleSideTriangles(targetTriangle, rightMesh, intersectionPoints, negativeSideVertexIndex);
			}
			else if (negativeSideVertexIndex.Count == 1)
			{
				// handle single vertex on negative side
				rightMesh.AddTriangle(CreateSingleSideTriangle(targetTriangle, intersectionPoints, negativeSideVertexIndex[0]));

				// handle double vertices on positive side
				AddDoubleSideTriangles(targetTriangle, leftMesh, intersectionPoints, positiveSideVertexIndex);
			}
		}

        /// <summary>
        /// Adds triangles to targetMesh handling the case where there are two vertices of the target triangle on the same side in addition to the intersectionPoints
        /// </summary>
        /// <param name="targetTriangle">the target triangle that must be cut</param>
        /// <param name="targetMesh">the target mesh to which add the triangles</param>
        /// <param name="intersectionPoints">the intersection point with the cut plane</param>
        /// <param name="sideVertexIndex">the list of indexes of the vertices on the same side</param>
        private void AddDoubleSideTriangles(MeshTriangle targetTriangle, CutGeneratedMesh targetMesh, IntersectionPoint[] intersectionPoints, List<int> sideVertexIndex)
		{
			// first triangle:
			// the first triangle's vertices will consist of both the intersection points and one target triangle vertex
			Vector3[] firstTriangleVertices = new Vector3[3] { targetTriangle.vertices[sideVertexIndex[0]], intersectionPoints[0].vertex, intersectionPoints[1].vertex };
			Vector3[] firstTriangleNormals = new Vector3[3] { targetTriangle.normals[sideVertexIndex[0]], intersectionPoints[0].normal, intersectionPoints[1].normal };
			Vector2[] firstTriangleUvs = new Vector2[3] { targetTriangle.uvs[sideVertexIndex[0]], intersectionPoints[0].uv, intersectionPoints[1].uv };
			MeshTriangle firstTriangle = new MeshTriangle(firstTriangleVertices, firstTriangleNormals, firstTriangleUvs, targetTriangle.subMeshIndex);

			if (IsFacingWrongSide(firstTriangleVertices, firstTriangleNormals[0]))
				FlipTriangle(firstTriangle);

			targetMesh.AddTriangle(firstTriangle);

			// second triangle:
			// for the second triangle, the vertices will consist of both the vertices on the same side of the target triangle and one of the two intersection points.
			// First, we must find which intersection point to use in order to avoid triangles overlapping
			int intersectionPointIndex = 0;
			for (int i = 0; i < 2; i++)
				if (Array.IndexOf<Vector3>(intersectionPoints[i].directlyConnectedVertices, targetTriangle.vertices[sideVertexIndex[1]]) != -1)
					intersectionPointIndex = i;

			Vector3[] secondTriangleVertices = new Vector3[3] { targetTriangle.vertices[sideVertexIndex[1]], targetTriangle.vertices[sideVertexIndex[0]], intersectionPoints[intersectionPointIndex].vertex };
			Vector3[] secondTriangleNormals = new Vector3[3] { targetTriangle.normals[sideVertexIndex[1]], targetTriangle.normals[sideVertexIndex[0]], intersectionPoints[intersectionPointIndex].normal };
			Vector2[] secondTriangleUvs = new Vector2[3] { targetTriangle.uvs[sideVertexIndex[1]], targetTriangle.uvs[sideVertexIndex[0]], intersectionPoints[intersectionPointIndex].uv };
			MeshTriangle secondTriangle = new MeshTriangle(secondTriangleVertices, secondTriangleNormals, secondTriangleUvs, targetTriangle.subMeshIndex);

			if (IsFacingWrongSide(secondTriangleVertices, secondTriangleNormals[0]))
				FlipTriangle(secondTriangle);

			targetMesh.AddTriangle(secondTriangle);
		}

        /// <summary>
        /// Creates a triangle handling the case where there is only one vertex of the target triangle on the same side in addition to the intersectionPoints
        /// </summary>
        /// <param name="targetTriangle">the target triangle that must be cut</param>
        /// <param name="intersectionPoints">the intersection point with the cut plane</param>
        /// <param name="index">the index of the vertex on the considered side</param>
        /// <returns>A MeshTriangle object</returns>
        private MeshTriangle CreateSingleSideTriangle(MeshTriangle targetTriangle, IntersectionPoint[] intersectionPoints, int index)
		{
			Vector3[] newTriangleVertices = new Vector3[3] { targetTriangle.vertices[index], intersectionPoints[0].vertex, intersectionPoints[1].vertex };
			Vector3[] newTriangleNormals = new Vector3[3] { targetTriangle.normals[index], intersectionPoints[0].normal, intersectionPoints[1].normal };
			Vector2[] newTriangleUvs = new Vector2[3] { targetTriangle.uvs[index], intersectionPoints[0].uv, intersectionPoints[1].uv };

			MeshTriangle output = new MeshTriangle(newTriangleVertices, newTriangleNormals, newTriangleUvs, targetTriangle.subMeshIndex);

			if (IsFacingWrongSide(newTriangleVertices, newTriangleNormals[0]))
				FlipTriangle(output);

			return output;
		}

		/// <summary>
		/// Checks if one triangle is facing on the wrong side.
		/// Useful to know if the triangle must be flipped or not
		/// </summary>
		/// <param name="triangleVertices">the vertices of the triangle</param>
		/// <param name="triangleNormal">the normal of the first vertex of the triangle</param>
		/// <returns>true if the triangle is facing in the wrong direction, false otherwise</returns>
		private bool IsFacingWrongSide(Vector3[] triangleVertices, Vector3 triangleNormal)
		{
			return Vector3.Dot(Vector3.Cross(triangleVertices[0] - triangleVertices[1], triangleVertices[0] - triangleVertices[2]), triangleNormal) < 0;
		}

		/// <summary>
		/// Flip the triangle by switching the first two elements in the vertices, normals and uvs arrays of the triangle
		/// </summary>
		/// <param name="triangle">the triangle to flip</param>
		private void FlipTriangle(MeshTriangle triangle)
		{
			Vector3 temp = triangle.vertices[0];

			triangle.vertices[0] = triangle.vertices[1];
			triangle.vertices[1] = temp;

			temp = triangle.normals[0];
			triangle.normals[0] = triangle.normals[1];
			triangle.normals[1] = temp;

			Vector2 temp2 = triangle.uvs[0];

			triangle.uvs[0] = triangle.uvs[1];
			triangle.uvs[1] = temp2;

		}

		/// <summary>
		/// Create a MeshTriangle object containing all the necessary informations for a mesh triangle, such as vertices, normals, uvs and the index of the submesh the triangle belongs to
		/// </summary>
		/// <param name="targetMesh">The original mesh the triangle belongs to</param>
		/// <param name="submeshIndex">The submesh index</param>
		/// <param name="submeshTriangles">The triangles of the submesh specified with the submesh index</param>
		/// <param name="triangleIndexOffset">The offset used to calculate the index used to access the arrays in order to extrapolate the correct informations for this triangle</param>
		/// <returns>An initialized MeshTriangle object</returns>
		private MeshTriangle GetTriangle(Mesh targetMesh, int submeshIndex, int[] submeshTriangles ,int triangleIndexOffset)
		{
			Vector3[] vertices = new Vector3[3];
			Vector3[] normals = new Vector3[3];
			Vector2[] uvs = new Vector2[3];

			for (int i = 0; i < 3; i++)
			{
				int index = submeshTriangles[triangleIndexOffset + i];
				vertices[i] = targetMesh.vertices[index];
				normals[i] = targetMesh.normals[index];
				uvs[i] = targetMesh.uv[index];
			}

			return new MeshTriangle(vertices, normals, uvs, submeshIndex);
		}
	}
}
